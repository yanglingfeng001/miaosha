# 秒杀系统项目开发手册：

## 开发工具：

IntelliJ IDEA（or Eclipse） + Navicat + Git + Chrome+Postman

## 开发技术：


前端技术 ：Bootstrap + jQuery + Thymeleaf（前后端分离后未使用）

后端技术 ：SpringBoot + MyBatis + MySQL

中间件技术 : Druid + Redis + RabbitMQ 

## 压力测试工具：

JMeter

## 部署说明：

- 下载sql文件夹中seckill.sql，导入到本地，数据库名为myseckill，其他参数默认
- 修改application.properties中mysql的url，rabbitmq配置以及redis配置等常规配置
- 不要更改默认端口
- 启动MainApplication，打开浏览器输入[localhost:8080/login/to_login]()进入到登录页面
- 输入[localhost:8080/goods/to_list]()查看商品列表

## 使用说明：

(1)登陆：

![屏幕快照 2021-03-26 21.53.12](1/操作图片/屏幕快照 2021-03-26 21.53.12.png)

（2）进入商品列表，点击详情查看商品详情

![屏幕快照 2021-03-26 21.53.16](/Users/yanglingfeng/IdeaProjects/miaosha/操作图片/屏幕快照 2021-03-26 21.53.16.png)

（3）查看商品详情，页面中有5s会自动刷新和失效的验证码，请快速输入

![屏幕快照 2021-03-26 21.53.21](/Users/yanglingfeng/IdeaProjects/miaosha/操作图片/屏幕快照 2021-03-26 21.53.21.png)

（4）如果用户已经秒杀过，提示不能重复秒杀，用户输入错误验证码或者不输入验证码会提示验证码有问题

![屏幕快照 2021-03-26 21.53.40](/Users/yanglingfeng/IdeaProjects/miaosha/操作图片/屏幕快照 2021-03-26 21.53.40.png)

![屏幕快照 2021-03-26 21.53.49](/Users/yanglingfeng/IdeaProjects/miaosha/操作图片/屏幕快照 2021-03-26 21.53.49.png)

（5）通过验证码且未秒杀过可以秒杀，点击确认查看订单详情

![屏幕快照 2021-03-26 21.54.20](/Users/yanglingfeng/IdeaProjects/miaosha/操作图片/屏幕快照 2021-03-26 21.54.20.png)

![屏幕快照 2021-03-26 21.54.22](/Users/yanglingfeng/IdeaProjects/miaosha/操作图片/屏幕快照 2021-03-26 21.54.22.png)

## 一些问题：

### 1. 如何保证不卖超

有两种情况可能会导致卖超：（1）一个用户同时发出了多个请求，如果库存足够，没加限制，用户就可以下多个订单。（2）减库存的sql上没有加库存数量的判断，并发的时候也会导致把库存减成负数。

我们的解决办法：

对于（1）：前端加验证码，防止用户同时发出多个请求，在后端的miaosha_order表中，对user_id和goods_id加唯一索引，确保一个用户对一个商品绝对不会生成两个订单。

对于（2）：我们的减库存的sql上应该加上库存数量的判断：

![img](file:////Users/yanglingfeng/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.jpg)

数据库更新记录的时候会加锁，实际上是串行的执行update的，因此绝对不会卖超！

### 2. Redis中的库存如何与DB中的库存保持一致？

Redis中的数量不是库存，它的作用仅仅时候只是为了阻挡多余的请求透传到db，起到一个保护DB的作用。因为秒杀商品的数量是有限的，比如只有10个，让1万个请求去访问DB是没有意义的，因为最多只有10个请求会下单成功，剩余的9990个请求都是无效的，是可以不用去访问db而直接失败的。

因此，这是一个伪问题，我们是不需要保持一致的。

### 3. Redis预减成功，DB扣减库存失败怎么办？

两大类情况可导致redis预减成功而DB扣减失败：

（1）   如果一个用户发出了多个请求（不管何种手段），而这些所有的请求比所有其他用的请求都更快的到达了服务器，这个时候如果库存足够，就会出现redis预减多次，而只能下单成功一次（前提是：这个用户的多个请求比网站的其他用户的请求都更快的到达服务器，这在网络环境不可知的情况下，基本不可能）

（2）   还有就是在生成订单的过程中发生了不可预料的异常，也会导致redis扣减成功，而db扣减失败（如果是DB出现了异常，可能所有的订单都无法生成，但是只要存在redis预减，活动就可以正常结束）

因此，在初始化的时候，redis中的数量可以多于db的库存数量。

出现这种情况的后果是什么？

（1）   对用户而言，秒杀不中是正常现象，秒杀中才是意外，单个用户能否秒杀中本来就是小概率事件，出现这种情况对用户而言是没有任何影响的。

（2）   对商户而言，本来就是为了做活动拉流量拉人气的，卖不完还可以省一部分费用，但是活动还是正常参与了，也是没有任何影响

（3）   对网站而言，网站最重要的是用户体验，只要网站不崩，用户不骂娘，对网站也没有任何影响。

所以，卖不完是完全允许的，但是卖超是绝对不允许的！卖超的这部分钱商家是不会出的，需要网站自己来出。

### 4. 为什么Redis中的数量会减成负数？

![img](file:////Users/yanglingfeng/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.jpg)

假如redis中的数量是1，这个时候同时过来100个请求，大家一起去执行decr,数量就会减成-99，这是正常的。

### 5. 为什么要单独维护一个秒杀结束的标志？

（1）   前面也提过，所有的秒杀相关的接口都要加上活动是否结束的标志，如果结束就直接返回了，包括轮询的接口，防止一直轮询没法结束。

（2）   管理后台也可以手动的更改这个标志，防止出现活动开始以后就没法结束这种意外的发生。

### 6. 如果用户秒杀成成功了，但是没有付款怎么办？

一般网站都会有下单30分钟不支付订单自动取消这样的操作，此时就需要把库存再加回去，因此又叫回仓。

可以在创建订单以后，把订单写入到延迟队列里面（RabbitMQ、RocketMQ都支持），如果在有效期之内用户做了付款，则从队列删除，否则等延迟队列数据出队的时候，再去查询数据库订单的状态，如果是未支付则需要回仓。回仓无非就是重置redis和mysql的数据，包括一些秒杀结束的状态等等。

### 7. 为什么要做隐藏秒杀接口地址？

（1）   html是可以被右键->查看源代码，如果秒杀地址写死在源文件中，是很容易就被恶意用户拿到的，就可以被机器人利用来刷接口。

（2）   通过一个接口来返回秒杀地址的好处是，可以在活动临近开始的时候，服务端可以把地址换掉，这样就算恶意用户提前拿到了地址，但是拿到的也是一个不可用的地址。

（3）   服务端可以通过管理后台来随时修改接口的地址。

### 8. GET跟POST的区别是什么？

（1）   传参方式，GET放在url后面，post放在http的body，GET更不安全

（2）   参数长度，浏览器对url后面的参数长度有限制，post也有限制，但是post要比get大得多。这是浏览器加的限制，跟Http协议无关

（3）   GET的页面可以被缓存，POST的不可以

（4）   GET可以添加收藏，POST不可以

（5）   GET可以后退刷新，POST刷新会重新提交数据。

（6）   GET不能做文件上传，POST可以。

（7）   以上都是表象，最根本的区别是语义上的区别：GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）。POST的语义是根据请求报文对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。简单地说GET是获取数据，POST是修改数据。跟Restful还有点区别，Restful规范里面，GET是获取，POST是添加，PUT是修改，DELETE是删除。